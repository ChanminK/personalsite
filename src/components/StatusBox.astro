---
interface Props {
  label?: string;
  value?: string;
  mode?: 'docked' | 'bounce';
  storageKey?: string;
}
const {
  label = 'Now Thinking',
  value = 'Booting ideasâ€¦',
  mode = 'docked',
  storageKey = 'statusbox'
} = Astro.props;
---

<style>
    .floating {
    position: fixed;
    left: 12vw;
    top: 18vh;
    margin: 0;
    z-index: 40;
  }
</style>

<div
  class={mode === 'bounce' ? 'floating status-wrap' : 'status-wrap'}
  data-key={storageKey}
  data-mode={mode}
  data-label={label}
  data-value={value}
>
  <div class="status" role="status" aria-live="polite">
    <span class="tag">{label}:</span>&nbsp;<span class="value">{value}</span>
    <button class="x" aria-label="Close status" data-close>&times;</button>
  </div>
</div>

<script is:inline>
(() => {
  // Select the wrapper without any Astro interpolation:
  const root = (document.currentScript && document.currentScript.previousElementSibling) as HTMLElement | null;
  if (!root) return;

  const key  = root.getAttribute('data-key')  || 'statusbox';
  const mode = root.getAttribute('data-mode') || 'docked';
  const box  = root.querySelector('.status') as HTMLElement | null;
  const btn  = root.querySelector('[data-close]') as HTMLButtonElement | null;
]
  if (sessionStorage.getItem(key + '-closed') === '1') {
    root.style.display = 'none';
    return;
  }

  let stop = () => {};

  btn?.addEventListener('click', () => {
    sessionStorage.setItem(key + '-closed', '1');
    try { stop(); } catch {}
    root.style.display = 'none';
  });

  if (mode !== 'bounce' || !box) return;

  let raf = 0;
  let x = Math.max(8, root.offsetLeft || innerWidth  * 0.12);
  let y = Math.max(8, root.offsetTop  || innerHeight * 0.18);
  let vx = 1.1, vy = 1.0; // px/frame
  const M = 8;
  let reduce = false;
  try { reduce = matchMedia('(prefers-reduced-motion: reduce)').matches; } catch {}

  function frame(){
    const r  = box.getBoundingClientRect();
    const bw = r.width, bh = r.height;

    x += vx; y += vy;
    if (x <= M || x + bw >= innerWidth  - M) vx *= -1;
    if (y <= M || y + bh >= innerHeight - M) vy *= -1;

    root.style.left = Math.max(M, Math.min(innerWidth  - bw - M, x)) + 'px';
    root.style.top  = Math.max(M, Math.min(innerHeight - bh - M, y)) + 'px';

    raf = requestAnimationFrame(frame);
  }
  function start(){ if (!reduce && !raf) raf = requestAnimationFrame(frame); }
  stop = function(){ if (raf) cancelAnimationFrame(raf); raf = 0; };

  let dragging=false, dx=0, dy=0;
  box.addEventListener('mousedown', (e)=>{
    dragging=true; stop();
    const rr = root.getBoundingClientRect();
    dx = e.clientX - rr.left; dy = e.clientY - rr.top;
    document.body.style.userSelect='none';
  });
  window.addEventListener('mousemove', (e)=>{
    if (!dragging) return;
    root.style.left = (e.clientX - dx) + 'px';
    root.style.top  = (e.clientY - dy) + 'px';
  });
  window.addEventListener('mouseup', ()=>{
    if (!dragging) return;
    dragging=false; document.body.style.userSelect='';
    start();
  });

  document.addEventListener('visibilitychange', () => document.hidden ? stop() : start());
  window.addEventListener('blur',  stop);
  window.addEventListener('focus', start);

  start();
})();
</script>
